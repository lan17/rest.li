/*
   Copyright (c) 2012 LinkedIn Corp.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/

package com.linkedin.restli.server.twitter;

import com.linkedin.parseq.promise.Promise;
import com.linkedin.restli.common.PatchRequest;
import com.linkedin.restli.common.attachments.RestLiAttachmentReader;
import com.linkedin.restli.server.BatchCreateRequest;
import com.linkedin.restli.server.BatchCreateResult;
import com.linkedin.restli.server.BatchDeleteRequest;
import com.linkedin.restli.server.BatchPatchRequest;
import com.linkedin.restli.server.BatchUpdateRequest;
import com.linkedin.restli.server.BatchUpdateResult;
import com.linkedin.restli.server.CreateResponse;
import com.linkedin.restli.server.PagingContext;
import com.linkedin.restli.server.ResourceLevel;
import com.linkedin.restli.server.UpdateResponse;
import com.linkedin.restli.server.annotations.Action;
import com.linkedin.restli.server.annotations.ActionParam;
import com.linkedin.restli.server.annotations.Finder;
import com.linkedin.restli.server.annotations.Optional;
import com.linkedin.restli.server.annotations.PagingContextParam;
import com.linkedin.restli.server.annotations.QueryParam;
import com.linkedin.restli.server.annotations.RestLiAttachmentsParam;
import com.linkedin.restli.server.annotations.RestLiCollection;
import com.linkedin.restli.server.annotations.RestMethod;
import com.linkedin.restli.server.resources.KeyValueResource;
import com.linkedin.restli.server.resources.ResourceContextHolder;
import com.linkedin.restli.server.twitter.TwitterTestDataModels.Status;
import com.linkedin.restli.server.twitter.TwitterTestDataModels.StatusType;

import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * CollectionResource containing all statuses
 *
 * @author dellamag
 */
@RestLiCollection(name="promisestatuses",
                    keyName="statusID")
public class PromiseStatusCollectionResource extends ResourceContextHolder implements KeyValueResource<Long, Status>
{
  /**
   * Gets a sample of the timeline of statuses generated by all users
   */
  @Finder("public_timeline")
  public Promise<List<Status>> getPublicTimeline(@PagingContextParam PagingContext pagingContext)
  {
    throw new AssertionError("should be mocked");
  }

  /**
   * Gets the status timeline for a given user
   */
  @Finder("user_timeline")
  public Promise<List<Status>> getUserTimeline(@Optional("true") @QueryParam("includeReplies") Boolean includeReplies, @PagingContextParam(defaultCount = 100, defaultStart = 10) PagingContext pagingContext)
  {
    throw new AssertionError("should be mocked");
  }

  /**
   * Keyword search for statuses
   *
   * @param keywords keywords to search for
   * @param since a unix timestamp. If present, only statuses created after this time are returned
   */
  @Finder("search")
  public Promise<List<Status>> search(@QueryParam("keywords") String keywords,
                             @QueryParam("since") @Optional("-1") long since,
                             @QueryParam("type") @Optional StatusType type)
  {
    throw new AssertionError("should be mocked");
  }


  /**
   * Creates a new Status
   */
  @RestMethod.Create
  public Promise<CreateResponse> create(Status entity)
  {
    throw new AssertionError("should be mocked");
  }

  /**
   * Gets a batch of statuses
   */
  @RestMethod.BatchGet
  public Promise<Map<Long, Status>> batchGet(Set<Long> ids)
  {
    throw new AssertionError("should be mocked");
  }

  /**
   * Gets a single status resource
   */
  @RestMethod.Get
  public Promise<Status> get(Long key)
  {
    throw new AssertionError("should be mocked");
  }

  /**
   * Deletes a status resource
   */
  @RestMethod.Delete
  public Promise<UpdateResponse> delete(Long key)
  {
    throw new AssertionError("should be mocked");
  }

  /**
   * Partially updates a single status resource
   */
  @RestMethod.PartialUpdate
  public Promise<UpdateResponse> update(Long key, PatchRequest<Status> request)
  {
    throw new AssertionError("should be mocked");
  }

  /**
   * Updates (overwrites) a single status resource
   */
  @RestMethod.Update
  public Promise<UpdateResponse> update(Long key, Status entity)
  {
    throw new AssertionError("should be mocked");
  }

  @RestMethod.BatchUpdate
  public Promise<BatchUpdateResult<Long, Status>> batchUpdate(
          BatchUpdateRequest<Long, Status> entities)
  {
    throw new AssertionError("should be mocked");
  }

  @RestMethod.BatchPartialUpdate
  public Promise<BatchUpdateResult<Long, Status>> batchUpdate(
          BatchPatchRequest<Long, Status> entityUpdates)
  {
    throw new AssertionError("should be mocked");
  }

  @RestMethod.BatchCreate
  public Promise<BatchCreateResult<Long, Status>> batchCreate(
          BatchCreateRequest<Long, Status> entities)
  {
    throw new AssertionError("should be mocked");
  }

  @RestMethod.BatchDelete
  public Promise<BatchUpdateResult<Long, Status>> batchDelete(
          BatchDeleteRequest<Long, Status> ids)
  {
    throw new AssertionError("should be mocked");
  }

  /**
   * Ambiguous action binding test case
   */
  @Action(name="forward",
          resourceLevel= ResourceLevel.ENTITY)
  public void forward(@ActionParam("to") long userID)
  {
    throw new AssertionError("should be mocked");
  }

  @Action(name="streamingAction")
  public Promise<Long> streamingAction(@ActionParam("metadata") String metadata,
                              @RestLiAttachmentsParam RestLiAttachmentReader attachmentReader)
  {
    throw new AssertionError("should be mocked");
  }
}
